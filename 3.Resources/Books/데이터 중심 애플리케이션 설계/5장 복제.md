---
date created: 2023-10-13 22:59
date updated: 2023-10-13 23:00
---

- 복제가 필요한 이유
  - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
  - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
  - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.
- 세가지 복제 알고리즘이 있다. `단일 리더(Single Leader)` `다중 리더 (Multi Leader)` `리더 없는 (Leaderless)`
- 복제에는 트레이드오프가 있음
  - 동기 VS 비동기
  - 잘못된 복제본을 어떻게 처리할지

## 리더와 팔로워

- 데이터베이스의 복사본을 저장하는 각 노드를 `복제 서버 (replica)` 라고 한다.
- 가장 일반적인 해결책이 `리더 기반 복제` 기법을 사용한다.

1. 복제 서버중 하나를 `리더(Leader)`로 지정한다.
2. 클라이언트가 데이터베이스에 쓰기 요청을 할 때는 리더에게 보내야 한다.
3. 리더는 로컬 저장소에 새로운 데이터를 기록한다.
4. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 `복제 로그(replication log)` `변경 스트림(change stream)`의 일부로 팔로워에게 전송한다.

- 읽기 요청은 `리더` 또는 `팔로워` 둘다 가능하다
- 쓰기 요청은 `리더`만 가능하다

## 동기 VS 비동기

![[Pasted image 20231013213533.png]]

- 다이어그램은 팔로워2가 메시지를 처리하기 전까지 상당한 지연이 있다.

- 동기식 복제
  - 장점 : 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
  - 단점 : 동기 팔로워가 응답하지 않는다면 쓰기가 처리 될 수 없다.

- 모든 팔로워가 동기식인 상황은 비현실적이다.

- 보통 리더 기반 복제는 비동기식으로 구성된다.

- 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.

- 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있다.

- 많은 팔로워가 있거나, 지리적으로 분산됐다면 비동기식 복제를 널리 사용한다.

### 복제에 대한 연구

- 리더 작동이 실패한다면 비동기식 복제 시스템의 유실은 심각한 문제가 될 수 있다.
- `체인 복제`는 애저 저장소와 같은 일부 시스템에 성공적으로 구현된 동기식 복제의 변형

### 새로운 팔로워 설정

- 때때로 복사 결과가 유효하지 않을 수 있다.
- 락을 걸어서 일관성 있게 만들 수 있지만 고가용성 목표에 부합하지 않는다.
- 팔로워 설정은 중단시간 없이 수행 가능

1. 전체 데이터베이스를 잠그지 않고 스냅숏을 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청 한다. 스냅숏이 리더의 복제 로그 정확한 위치와 연관돼야 한다.
4. 팔로워가 스냅숏이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말한다.

## 노드 중단 처리

### 팔로워 장애 : 따라잡기 복구

- 각 팔로워는 데이터 변경 로그를 로컬 디스크에 저장한다.
- 팔로워가 죽었다가 재시작해도 팔로워는 매우 쉽게 복구할수 있다.

1. 결함이 발생하기 전에 처리 한 마지막 트랜잭션을 알아낸다.
2. 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 변경을 요청 할 수 있다.
3. 변경이 다 적용되면 리더를 다 따라잡을 수 있다.

### 리더 장애 : 장애 복구

- 리더에 장애가 발생하면 팔로워중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이필요하다.
- 장애 복구 단계
  1. 리더가 장애인지 판단한다.
     1. 주로 타임아웃 같은 로직을 사용한다.
  2. 새로운 리더를 선택한다.
     1. 선출 과정에 의해 새로운 리더가 선정되거나 이전에 선출된 `제어 노드`를 선택한다.
     2. 가장 적합한 후보는 리더의 초신 데이터 변경사항을 가진 복제서버
  3. 새로운 리더 사용을 위해 시스템을 재설정한다.
     1. 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보낼 수 있다.
- `비동기 복제`를 사용하면 이전 리더가 실패하기 전 일부 쓰기를 수신하지 못할수도 있다.
  - 가장 쉬운 방법은 복제되지 않은 쓰기를 폐기하는 방법.
  - 내구성 문제가 있음
- 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 위험하다.
  - Github Auto Increment 키 문제
- 특정 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수도 있다.`Split Brain`
  - 일부 시스템에서는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있다.

## 복제 로그 구현

### 구문 기반 복제

- 리더가 모든 쓰기 요청 `구문(Statement)` 을 기록하고 구문 로그를 팔로워에게 전송한다.

- `NOW()` `RAND()`같은 랜덤 함수는 복제 서버마다 다른 값을 생성

- Auto Increment를 사용하면 구문은 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다.

- 부수 효과를 가진 구문(`트리거` , ` 스토어드 프로시저  `  `사용자 정의 함수` 완벽하게 결정적이지 않으면 문제가 됌

### 쓰기 전 로그 배송

- 모든 쓰기는 로그가 기록 되고 로그 저장소에 기록이 된다.
- 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.
- 팔로워가 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어진다.
- `B Tree`에서는 `Write-ahead log`와 같은 기능이 있어서 고장 나도 일관성 있는 상태로 색인을 복원할수 있다.
- 단점 : 
	- 로그가 제일 저수준의 데이터를 기술
	- `WAL`은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 가지고 있음
	- 따라서 스토리지 엔진과 밀접하게 의존된다.
	- 리더와 팔로워의 데이터베이스 엔진 버전을 맞춰야 됌
	- 버전의 불일치를 허용하지 않는다면 업그레이드 할 때 중단시간이 필요하다


### 논리적 로그 복제
- 복제와 저장소 엔진을 위해 다른 로그 형식을 사용한다.
- 이를 `논리적 로그` 라고 부른다
- RDB에서 논리적 로그는 대개 로우 단위로 쓰기를 기술한 레코드 열이다.
	- 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함
	- 삭제된 로우의 로그는 고유하게 식별하는데 필요한 정보를 포함
	- 갱신된 로그는 고유 식별 정보와 모든 컬럼의 새로운 값을 포함
- 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성 한다음 트랜잭션이 커밋됐음을 레코드에 표시
- 리더와 팔로워에서 다른버전의 소프트웨어나 다른저장소 엔진을 실행도 가능
- `논리적 로그`는 외부 애플리케이션이 파싱하기 더 쉽다.

### 트리거 기반 복제
- 앞의 방법들은 데이터베이스 시스템에 의해 구현된다.
- 데이터의 서브셋만 복제, 다른 종류의 데이터베이스로 복제, 충돌 해소 로직이 필요하면 복제를 애플리케이션층으로 옮겨야 한다.
- 대개 `트리거`나 `스토어드 프로시저`를 사용한다.
- 트리거 기반 복제는 다른 복제 방식보다 많은 오버헤드가 있다.
- 유연성이 필요할떄 유용하다.

## 복제 지연 문제

- `읽기 확장(read-scaling)` 에서는 팔로워를 더 추가하면 읽기 요청 처리 용량을 늘릴 수 있따.
- 비동기에서만 동작
- 동기식으로 하면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.
- `비동기 팔로워` 에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.
- 
