---
date created: 2023-10-13 22:59
date updated: 2023-10-17 22:46
---
- 복제가 필요한 이유
  - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
  - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
  - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.
- 세가지 복제 알고리즘이 있다. `단일 리더(Single Leader)` `다중 리더 (Multi Leader)` `리더 없는 (Leaderless)`
- 복제에는 트레이드오프가 있음
  - 동기 VS 비동기
  - 잘못된 복제본을 어떻게 처리할지

## 리더와 팔로워

- 데이터베이스의 복사본을 저장하는 각 노드를 `복제 서버 (replica)` 라고 한다.
- 가장 일반적인 해결책이 `리더 기반 복제` 기법을 사용한다.

1. 복제 서버중 하나를 `리더(Leader)`로 지정한다.
2. 클라이언트가 데이터베이스에 쓰기 요청을 할 때는 리더에게 보내야 한다.
3. 리더는 로컬 저장소에 새로운 데이터를 기록한다.
4. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 `복제 로그(replication log)` `변경 스트림(change stream)`의 일부로 팔로워에게 전송한다.

- 읽기 요청은 `리더` 또는 `팔로워` 둘다 가능하다
- 쓰기 요청은 `리더`만 가능하다

## 동기 VS 비동기

![[Pasted image 20231013213533.png]]

- 다이어그램은 팔로워2가 메시지를 처리하기 전까지 상당한 지연이 있다.

- 동기식 복제
  - 장점 : 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장
  - 단점 : 동기 팔로워가 응답하지 않는다면 쓰기가 처리 될 수 없다.

- 모든 팔로워가 동기식인 상황은 비현실적이다.

- 보통 리더 기반 복제는 비동기식으로 구성된다.

- 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.

- 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있다.

- 많은 팔로워가 있거나, 지리적으로 분산됐다면 비동기식 복제를 널리 사용한다.

### 복제에 대한 연구

- 리더 작동이 실패한다면 비동기식 복제 시스템의 유실은 심각한 문제가 될 수 있다.
- `체인 복제`는 애저 저장소와 같은 일부 시스템에 성공적으로 구현된 동기식 복제의 변형

### 새로운 팔로워 설정

- 때때로 복사 결과가 유효하지 않을 수 있다.
- 락을 걸어서 일관성 있게 만들 수 있지만 고가용성 목표에 부합하지 않는다.
- 팔로워 설정은 중단시간 없이 수행 가능

1. 전체 데이터베이스를 잠그지 않고 스냅숏을 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청 한다. 스냅숏이 리더의 복제 로그 정확한 위치와 연관돼야 한다.
4. 팔로워가 스냅숏이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말한다.

## 노드 중단 처리

### 팔로워 장애 : 따라잡기 복구

- 각 팔로워는 데이터 변경 로그를 로컬 디스크에 저장한다.
- 팔로워가 죽었다가 재시작해도 팔로워는 매우 쉽게 복구할수 있다.

1. 결함이 발생하기 전에 처리 한 마지막 트랜잭션을 알아낸다.
2. 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 변경을 요청 할 수 있다.
3. 변경이 다 적용되면 리더를 다 따라잡을 수 있다.

### 리더 장애 : 장애 복구

- 리더에 장애가 발생하면 팔로워중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하다.
- 장애 복구 단계
  1. 리더가 장애인지 판단한다.
     1. 주로 타임아웃 같은 로직을 사용한다.
  2. 새로운 리더를 선택한다.
     1. 선출 과정에 의해 새로운 리더가 선정되거나 이전에 선출된 `제어 노드`를 선택한다.
     2. 가장 적합한 후보는 리더의 최신 데이터 변경사항을 가진 복제서버
  3. 새로운 리더 사용을 위해 시스템을 재설정한다.
     1. 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보낼 수 있다.
- `비동기 복제`를 사용하면 이전 리더가 실패하기 전 일부 쓰기를 수신하지 못할수도 있다.
  - 가장 쉬운 방법은 복제되지 않은 쓰기를 폐기하는 방법.
  - 내구성 문제가 있음
- 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 위험하다.
  - Github Auto Increment 키 문제
- 특정 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수도 있다.`Split Brain`
  - 일부 시스템에서는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 메커니즘이 있다.

## 복제 로그 구현

### 구문 기반 복제

- 리더가 모든 쓰기 요청 `구문(Statement)` 을 기록하고 구문 로그를 팔로워에게 전송한다.

- `NOW()` `RAND()`같은 랜덤 함수는 복제 서버마다 다른 값을 생성

- Auto Increment를 사용하면 구문은 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다.

- 부수 효과를 가진 구문(`트리거` , ` 스토어드 프로시저  `  `사용자 정의 함수` 완벽하게 결정적이지 않으면 문제가 됌

### 쓰기 전 로그 배송

- 모든 쓰기는 로그가 기록 되고 로그 저장소에 기록이 된다.
- 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.
- 팔로워가 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어진다.
- `B Tree`에서는 `Write-ahead log`와 같은 기능이 있어서 고장 나도 일관성 있는 상태로 색인을 복원할수 있다.
- 단점 :
  - 로그가 제일 저수준의 데이터를 기술
  - `WAL`은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 가지고 있음
  - 따라서 스토리지 엔진과 밀접하게 의존된다.
  - 리더와 팔로워의 데이터베이스 엔진 버전을 맞춰야 됌
  - 버전의 불일치를 허용하지 않는다면 업그레이드 할 때 중단시간이 필요하다

### 논리적 로그 복제

- 복제와 저장소 엔진을 위해 다른 로그 형식을 사용한다.
- 이를 `논리적 로그` 라고 부른다
- RDB에서 논리적 로그는 대개 로우 단위로 쓰기를 기술한 레코드 열이다.
  - 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함
  - 삭제된 로우의 로그는 고유하게 식별하는데 필요한 정보를 포함
  - 갱신된 로그는 고유 식별 정보와 모든 컬럼의 새로운 값을 포함
- 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성 한다음 트랜잭션이 커밋됐음을 레코드에 표시
- 리더와 팔로워에서 다른버전의 소프트웨어나 다른저장소 엔진을 실행도 가능
- `논리적 로그`는 외부 애플리케이션이 파싱하기 더 쉽다.

### 트리거 기반 복제

- 앞의 방법들은 데이터베이스 시스템에 의해 구현된다.
- 데이터의 서브셋만 복제, 다른 종류의 데이터베이스로 복제, 충돌 해소 로직이 필요하면 복제를 애플리케이션층으로 옮겨야 한다.
- 대개 `트리거`나 `스토어드 프로시저`를 사용한다.
- 트리거 기반 복제는 다른 복제 방식보다 많은 오버헤드가 있다.
- 유연성이 필요할떄 유용하다.

## 복제 지연 문제

- `읽기 확장(read-scaling)` 에서는 팔로워를 더 추가하면 읽기 요청 처리 용량을 늘릴 수 있따.
- 비동기에서만 동작
- 동기식으로 하면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.
- `비동기 팔로워` 에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.
- 동시에 리더와 팔로워에 동일한 질의를 수행하면 서로 다른 결과를 얻을 수도 있다.
- 잠시 기다리면 팔로워가 리더를 따라잡게되고 이를 `최종적 일관성` 이라한다.

### 자신이 쓴 내용 읽기

- 사용자가 쓰기를 한 다음 바로 읽으면 아직 복제 서버에 반영되지 않았을 수 있다.

- 이런 상황에서 `쓰기 후 읽기 일관성` 이 필요하다.

- 사용자가 페이지를 새로고침 했을 때 항상 자신이 제출한 갱신을 모든 갱신을 볼 수 있음을 보장

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다.
  - 특정 나만 편집 할 수 있는 페이지나 정보들은 리더에서 읽을 수 있다.

- 마지막 갱신 시간을 찾아서 마지막 갱신 후 1분 동안은 리더에서 읽기를 수행한다.

- 가장 최근 쓰기의 타임스탬프를 기억 할 수 있다.
  - 복제 서버가 아직 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리
  - 복제 서버가 따라잡을때까지 질의를 대기시킬 수 있다.

- 복제 서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공하는 요청은 리더가 포함된 데이터센터로 라우팅돼야 한다.

- 동일한 사용자가 여러 디바이스로 서비스를 접근할때도 문제가 발생한다.

- 이 경우에는 디바이스간 읽기 일관성이 있어야 한다.

- 디바이스 간 쓰기후 읽기 일관성을 고려하면 여러 문제를 더 고민해야 한다.
  - 사용자의 마지막 갱신 타임스탬프를 기억해야하는 접근 방식은 어렵다.
    - 한 디바이스 발생한 갱신을 알 수 없기 때문
  - 복제 서버가 여러 데이터센터간에 분산돼 있다면 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다.

### 단조 읽기(Monotonic Read)

- 사용자가 `시간이 거꾸로 흐르는 현상`을 목격할 수 있다.
- `단조 읽기`는 `강한 일관성`보다는 덜한 보장이지만 `최종적 일관성`보다는 강한 보장이다.
- 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.
- 단조 읽기를 달성하는 방법 중 하나는 각 사용자의 읽기가 `항상 동일한 복제 서버`에서 수행 되게끔 한다. (사용자 id 해시로 구분)
- 하지만 복제 서버가 고장나면 질의를 다른 복제 서버로 라우팅 해야 한다.

### 일관된 순서로 읽기

> 푼스 씨 : 미래에 대해 얼마나 멀리 볼 수 있나요, 케이크 부인?
>
> 케이크 부인 : 보통 10초 정도요, 푼스 씨.

- 두 문장이 인과성이 있고, 항상 올바른 순서대로 메시지를 수신해야한다.

- `일관된 순서로 읽기` 보장 이 필요하다.

- `파티셔닝`된 데이터베이스에서 발생한다

- 사용자가 데이터베이스를 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.

- 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이 있음
  - `이전 관계` `동시성` 문제가 있음 [[p188]]

### 복제 지연을 위한 해결 책

- `최종적 일관성 시스템`으로 작업할때 복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해봐야 한다.
- 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척 하는 것이 문제 해결 방안임
- `트랜잭션` 을 통해 데이터베이스에게 `보장`을 제공할수 있다.
- 하지만 분산 데이터베이스로 전환하면서 많은 시스템이 `트랜잭션`을 포기함

## 다중 리더 복제

- 리더 기반 복제에는 리더가 하나만 존재하고 장애가 발생한다면 데이터베이스에 쓰기를 하기 어렵다는 단점이 있다.
- 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달 해야한다.
- 각 리더는 동시에 다른 리더의 팔로워 역할도 한다.

### 다중 리더 복제의 사용 사례

- 다중 리더는 복잡도에 비해 이점이 크지 않다.

#### 다중 데이터 센터 운영

- 여러 다른 데이터센터에 복제 서버가 있다고 가정
- `다중 리더 설정` 에서는 각 데이터센터마다 리더가 있을 수 있다.
- 각 데이터센터 내에는 보통의 리더 팔로워 복제를 사용하고, 데이터센터 간에는 각 데이터 센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.
- 단일 리더 설정 VS 다중 리더 설정

| 비고          | 단일 리더 설정                                                      | 다중 리더 설정                                                           |
| ----------- | ------------------------------------------------------------- | ------------------------------------------------------------------ |
| 성능          | 모든 쓰기는 인터넷을 통해 리더가 있는 데이터센터로 이동해야 함. 쓰기 지연시간을 상당히 늘리는 원인이 된다. | 로컬 데이터센터에서 처리 후 비동기 방식으로 다른 데이터센터에 복제. 데이터센터간 네트워크 지연은 사용자에게 숨겨진다. |
| 데이터센터 중단 내성 | 리더가 고장나면 팔로워를 리더로 승진 시킨다.                                     | 각 다른 데이터센터와 독립적으로 동작하고  온라인으로 돌아왔을때 복제를 따라잡는다.                     |
| 네트워크 문제 내성  | 데이터센터 쓰기가 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감하다.                   | 비동기 복제를 사용해서 네트워크 문제에 보다 잘 견딘다.                                    |
|             |                                                               |                                                                    |

- 단점 :
  - 동일한 데이터를 다른 두 개의 데이터센터에서 변경 할 수 있음
- 다중 리더 복제는 가능하면 피해야 하는 위험한 영역으로 간주된다.

#### 오프라인 작업을 하는 클라이언트

- 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우
- 캘린더 예시에서 디바이스가 오프라인 읽기 요청 ,쓰기 요청을 할 수 있어야 한다. 오프라인에서 온라인 상태가 됐을때 서버와 다른 디바이스를 동기화 한다.
- 이 경우 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있음.
- 모든 디바이스 상에서 캘린더의 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스가 있다.

#### 협업 편집

- 문서를 편집할때 변경 내용을 `로컬 복제 서버`에 적용 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제 한다
- 편집 충돌이 없으려면 잠금을 얻어야 한다.
- 다른 사용자는 커밋을 기다려야 함

### 쓰기 충돌 다루기

- `쓰기 충돌이` 가장 큰 문제임

![[Pasted image 20231016234013.png]]

- 변경을 비동기로 복제할 때 충돌을 감지 한다.
- 이 문제는 단일 리더 데이터베이스에서는 일어나지 않음

#### 동기 대 비동기 충돌 감지

- 단일에서는 첫번째 쓰기가 기 완료될때까지 두번째 쓰기를 차단하거나 중단하게 함
- 다중에서는 두 쓰기가 모두 성공하고 특정 시점에서 비동기로만 감지한다.
- 이때 이걸 해결하려면 너무 늦을 수 도 있다.
- 동기식으로 충돌감지를 할 수도 있는데, 이렇게 하면 주요 장점을 잃음

#### 충돌 회피

- 가장 간단한 전략
- 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 하면 충돌은 발생하지 않는다.
- 동일한 데이터센터로 라우팅해서 읽기와 쓰기를 하게끔 보장 할 수 있다.
- 데이터 센터가 고장나서 다른 데이터센터로 라우팅 하거나 다른 데이터센터가 더 가깝다면 리더를 변경 해야 할 수도 있다.
- 이럴때는 충돌회피가 실패한다.
- 다른 리더에서 동시 기록 가능성을 대처해야 한다.

#### 일관된 상태 수렴

- 모든 복제 계획은 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야 한다.

- `수렴(convergent)` 방식으로 충돌을 해소해야 한다.

- 각 쓰기에 고유 ID(타임스탬프, 긴 임의 숫자 등)를 부여하고 가장 높은 Id를 가진 쓰기를 고른다.

- 타임스탬프를 사용하는 경우를 `최종 쓰기 승리(last write win)`

- 데이터 유실 위험이 있다.

- 어떻게든 값을 병합하는 방법 ex) 정렬후 병합

- 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존한다. 나중에 충돌을 해결하는 애플리케이션 코드를 작성한다.

#### 사용자 정의 충돌 해소 로직

- 쓰기 수행중
  - 충돌을 감시하면 충돌 핸들러를 호출
- 읽기 수행중
  - 충돌을 감지하면 모든 충돌 쓰기를 저장
  - 사용자에게 충돌 내용을 보여주거나, 자동으로 해소할 수 있다.
- 충돌 해소는 전체 트랜잭션이 아니라 개별 로우나 문서 수준에서 적용
- 원자성을 가진 트랜잭션이면 각 쓰기는 별도로 간주된다.

#### 다중 리더 복제 토폴로지

![[Pasted image 20231016235000.png]]

- `전체 연결`이 가장 일반적이다.
- `원형 토폴로지`는 여러 노드를 거쳐야 한다.
- `별 모양 토폴로지`는 여러 노드를 거쳐야 한다. 노드들은 다른 노드로부터 받은 데이터변경 사항을 적용해야 한다.
- `원 모양`과 `별 모양`은 하나의 노드에 장애가 발생하면 다른 노드간 복제 메시지 흐름에 방해를 준다.
- `전체 연결`이 내결함성이 훨씬 더 뛰어나다.
- `전체 연결`은 일부 연결이 다른 연결보다 빠르면 일부 메시지가 다른 메시지를 `추월` 할 수도 있다.
- `버전 벡터` 기법을 사용 할 수 있다.
- [[5장 복제#동시 쓰기 감지]] 참조
- 하지만 대부분의 RDBMS에서는 충돌 감지 기법은 제대로 구현되지 않음

## 리더 없는 복제

- 일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.
- 아마존이 `Dynamo`를 시스템에서 사용한 이후 유행하기 시작
- `리악` `카산드라` `볼드모트` 는 `다이나모 스타일`이다.

### 노드가 다운됐을 때 데이터베이스에 쓰기

- 세개의 복제 서버를 가진 데이터베이스가 있고 복제 서버 중 하나를 사용할 수 없다고 가정
- 리더 기반 설정에서는 장애 복구를 실행해야 한다 .[[5장 복제#노드 중단 처리]] 참조
- 리더 없는 설정에서는 장애 복구가 필요하지 않다.

![[Pasted image 20231017173838.png]]

- 클라이언트가 쓰기를 모든 복제 서버에 병렬로 전송한다.
- 두 개의 복제 서버는 쓰기를 받았지만 하나는 쓰기를 하지 못함
- 모든 복제 서버의 요청을 보내서 두개의 복제 서버가 쓰기를 확인하면 최신 버전을 알 수 있어서 성공적인 응답을 받을 수 있다.
- 고장났던 노드가 복구되면 해당 노드에서 응답이 오래된 값을 얻을 수도 있다.
- 읽기 요청을 `병렬로 여러 노드`에 요청한다. 여러 노드에서 받은 응답값으로 어떤 응답이 최신 내용인지 결정한다.[[5장 복제#동시 쓰기 감지]] 참조

### 읽기 복구와 안티 엔트로피

- 다이나모 스타일은 두가지 메커니즘을 통해 따라잡기를 보완한다.

#### 읽기 복구

- 여러 요청을 보내서 오래된 응답 버전을 알게 된다면 해당 복제 서버에 새로운 값을 다시 기록하게 한다.

#### 안티 엔트로피 처리

- 일부 데이터스토어는 백그라운드 프로세스를 두고 복제 서버간 데이터 차이를 찾아서 지속적으로 업데이트 하는 방식을 사용한다.
- 특성 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

### 읽기와 쓰기를 위한 정족수

- 세개의 복제 서버가 있고 두개에 복제 서버에 쓰기가 성공한다면 2개를 읽으면 적어도 하나는 최신값인지 확인 할 수 있다.
- $n$개의 복제 서버가 있을 때 모든 쓰기는 $w$개의 노드에서 성공해야 쓰기가 확정되고, 모든 읽기는 최소한 $r$개의 노드에 질의해야 한다.
- w + r > n 이면 최신 값을 얻을 것이라 기대한다.
- r과 w를 `정족수 읽기`와 `정족수 쓰기`라 부른다.
- 일반적으로 `n`은 홀수로 하고 $w = r = (n + 1 ) / 2$로 설정한다.
- 쓰기가 적고 읽기가 많은 경우에는 $w=n, r=1$로 설정하면 좋다.
  - 읽기가 빨라지지만 노드 하나가 고장나면 모든 데이터베이스 쓰기가 실패하는 단점이 있음
- 필요한 w나 r개 노드보다 사용 가능한 노드가 적다면 쓰기나 읽기는 에러를 반환한다.

### 정족수 일관성의 한계

- w+ r >n 이 되게끔 설정하면 모든 읽기는 키의 최신 값을 반환할것을 기대
- $w + r <= n$으로도 설정이 가능 하다
  - 이 경우에는  w 과 r이 작을수록 오래된 값을 읽을 확률이 높다.
  - 최신 값을 가진 노드가 읽을 노드 그룹에 포함되지 않을 가능성이 높기 때문이다
  - 응답 할 수 있는 복제 서버의 수가 w나 r보다 밑이면 데이터베이스는 쓰기나 읽기가 불가능하다.
- w + r > n  경우에도 오래된 값을 반환하는 케이스가 존재
  1. w + r <=n 인 경우 r개의 노드와 w개의 노드가 겹치는 것을 보장하지 않는다.
  2. 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다. [[5장 복제#쓰기 충돌 다루기]], [[5장 복제#동시 쓰기 감지]]
  3. 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 서버에만 반영 될 수 있다.
  4. 전체 성공한 서버 숫자가 w보다 작다면 성공한 복제 서버에서 롤백하지 않는다.
  5. 모든 과정이 올바르게 동작해도 시점 문제로 에지 케이스가 있을 수 있다.
  6.
