---
tags:
  - 데이터중심애플리케이션설계
  - 데이터베이스
최근 수정한 날짜: 2023-09-22 14:00:35
책 이름: 데이터중심 애플리케이션 설계
챕터: 3장
읽기 시작한 날짜: 2024-09-18
다 읽은 날짜: 2024-09-22
---


## 데이터베이스를 강력하게 만드는 데이터 구조

- 두개의 배시 함수로 Key Value 데이터베이스를 구축 했을 때?
	```bash
#!/bin/bash
db_set(){
	echo "$1, $2" >> database
}

db_get(){

	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}

```

- 간단한 경우에는 꽤 잘 작동 하는 편
- db_get() 함수는 데이터베이스에 많은 레코드가 있으면 성능이 좋지 않다.
	- 매번 키를 찾을때마다 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다.
- 따라서 인덱스를 사용한다.

## 해시 색인

- 인메모리 데이터 구조인 해시맵이 있으니 이 구조를 인덱싱 하기 위해 구조를 사용 할 수도 있다.
- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지하는 전략
- 단순하지만 실제로 많이 사용하는 전략
- 파일에 새로운 키 값 쌍을 추가하면 오프셋을 반영하기 위해 해시맵도 갱신해야 한다.
- 비트캐스크(리악의 기본 저장소 엔진)가 근본적으로 사용하는 방식
- 항상 추가만 한다면 디스크 공간이 부족해짐
	- 특정 크기의 세그먼트로 나누게 된다.
	- 파일이 너무 많아지면 다시 중복을 제거하고 합치는 컴팩션 과정을 수행한다.
- 고려 사항 몇가지
	- 바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열
	- 레코드 삭제: 데이터 파일에 특수한 삭제 레코드를 추가. 이 레코드는 병합할때 이전 키 값을 무시하게 한다.
	- 고장 복구: 해시 맵을 메모리로 좀 더 빠르게 로딩할수 있게 스냅숏을 디스크에 저장한다.
	- 부분적으로 레코드 쓰기 : 체크섬을 통해 로그의 손상된 부분을 탐지해 무시할 수 있다.
	- 동시성 제어 : 하나의 스레드만 쓰기 작업수행
- 제약 사항 : 
	- 레인지 쿼리 불가능
	- 키가 너무 많으면 문제가 된다.
## SS테이블 (Sorted String Table)과 LSM 트리

- 기존의 로그 구조화 저장소를 키 값 쌍을 키로 정렬
- 키로 정렬된 형식을 `정렬된 문자열 테이블(Sorted String Table` 이라 부른다.
- 각 키는 병합된 세그먼트 파일 내에 한번만 나타나야 한다.

### SS 테이블의 장점
- 세그먼트 병합이 메모리보다 커도 간단하다. 머지 소트와 유사한 방식으로 병합
- 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다.
	- 정렬되어있기때문


### SS 테이블 생성과 유지
- 진짜로 데이터를 키로 정렬하려면 어떻게 해야하는가?? 
- 디스크보다 메모리에 유지하는 편이 훨씬 쉽다.
- Red Black Tree나 AVL 트리 같은 구조를 사용하면 임의 순서로 키를 삽입하고 정렬된 순서로 키를 읽을 수 있다.
- 그렇다면 해당 스토리지 엔진을 다음과 같이 설계가 가능하다.
	- 쓰기 요청시 Balanced Tree에 데이터를 추가한다.(이 트리를 ==MemTable== 이라 부른다.)
	- 멤테이블이 임계값보다 커지면 SS 테이블 파일로 디스크에 기록.
	- 새로운 SS 테이블이 데이터베이스의 가장 최신 세그먼트가 된다.
	- 읽기 요청을 제공하면 멤테이블에서 키를 찾는다. Newest -> Oldest 순으로 세그먼트를 탐색
	- 가끔 병합과 컴팩션 과정을 수행
- <mark style="background: #FFB86CA6;">데이터베이스가 고장나면 기록되지 않은 멤테이블에 있는 가장 최신 쓰기는 손실된다.</mark>


### SS 테이블에서 LSM(Log-Structured Merge-Tree) 트리 만들기
- 구글의 빅테이블에서 영감을 받은 ==카산드라== ==HBase== 에서도 유사한 저장소 엔진을 사용한다.

### 성능 최적화
- 멤테이블을 확인한 다음 키가 존재하지 않으면 가장 오래된 세그먼트까지 거슬러 올라가야 한다.
- 스토리지 엔진은 보통 [[블룸 필터(Bloom Filter)]]를 추가적으로 사용한다.
- 크기 계층(size-tiered) 레벨 컴팩션(leveled compaction)을 사용
- 레벨DB는 레벨 컴팩션 사용, HBase는 사이즈 계층, 카산드라는 둘다 지원
- 사이즈 계층 컴팩션은 좀 더 새롭고 작은 SS 테이블을 상대적으로 오래됐고 큰 SS 테이블에 연이어 병합한다.
- 레벨 컴팩션은 키 범위를 더 작은 SS 테이블로 나눔
- LST 트리의 기본 개념은 백그라운드에서 연속적으로 SS 테이블을 지속적으로 병합하는 것


### B Tree
- B 트리는 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기 작업을 한다.


### 신뢰할 수 있는 B 트리 만들기
- B 트리 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다.
- 덮어쓰기가 페이지 위치를 변경하지 않음 -> 참조는 그대로고 값만 바뀐다.
- 데이터베이스가 고장 상황에서 복구할수 있게 만들려면 쓰기전로그(redo log) 구조를 추가한다.
- 리두로그는 고장 이후 복구될때 일관성 있는 상태로 B 트리를 복원하는데 사용한다.
- 동시성 제어는 보통 래치로 트리의 데이터 구조를 보호한다.
- 유입 질의의 간섭 없이 백그라운드에서 모든 병합을 수행하고 이따금 새로운 세그먼트를 이전 세그먼트로 바꾼다.

### B 트리 최적화

- 일부 데이터베이스는 쓰기 시 복사 방식을 사용
- 페이지에 키를 축약해서 쓴다.
- 정렬된 순서로 조회해야하 한다면 어려울 수 있다.
- 트리에 포인터를 추가해서 리프들끼리 오고 갈 수 있다.

### LSM 트리와 B 트리 비교
- LSM은 쓰기에서 빠르고, B 트리는 읽기에서 빠르다.
- LSM은 컴팩션구조 때문에 좀 더 느리다.

### LSM 트리의 장점
- B 트리는 데이터를 두번 갱샌해야함
- 로그 구조화 자료구조도 컴팩션과 병학때무네 여러번 데이터를 쓴다.
- LSM 트리는 B 트리 보다 쓰기 처리량을 높힐 수 있다. 쓰기 증폭이 더 낮고, 순차적으로 컴팩션된 SS 테이블을 쓰기 때문
- LSM 트리는 압축률이 더 좋다. LSM 트리는 주기적으로 파편화를 없애기 위해 SS 테이블을 다시 기록하기 때문
- 낮은 쓰기 증폭과 파편화 감소는 SSD의 경우 더 유리하고, 데이터를 밀집해 표현하면 가능한 IO 대역폭에서 더 많은 읽기와 쓰기 요청이 가능하다.

### LSM 트리의 단점
- 디스크에서 비싼 컴팩션 연산이 끝날때까지 요청이 대기해야 하는 상황이 발생하기 쉽다.
- 데이터베이스가 점점 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요하다.
- 컴팩션 설정을 잘 하지 못하면 컴팩션이 유입 쓰기 속도를 따라갈 수가 없다.
- 세그먼트수가 계속해서 증가하게 되고 더 많은 세그먼트 파일을 확인해야해서 읽기 속도도 느려진다.


## 기타 색인 구조

### 색인 안에 값 저장하기
- 키는 질의가 검색하는 대상이지만 값은 두가지중 하나
	1. 질문의 실제로우
	2. 다른곳에 저장된 로우를 가리키는 참조 [[힙파일(Heap File)]]에 특정 순서 없이 데이터를 저장한다.
- 힙 파일에서 위치만 참조하고 실제 데이터는 일정한 곳에 유지한다.
- 인덱스에서 힙 파일로 다시 이동하는 일은 읽기 성능에 불이익이 너무 많기 때문에 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직하다.
- [[클러스터 인덱스]]와 포괄열이 있는 색인의 절충안이 커버링 인덱스
- 

## 멀티 컬럼 인덱스

- 결합 색인을 사용하는 것이 일반적
- (성, 이름)과 같은 인덱스 쌍을 주로 사용한다.

## 전문 검색과 퍼지(fuzzy) 색인
- 기존의 인덱스는 철자가 틀린 단어와 같이 유사한 인덱스에 대허서는 검색 할 수 없다.
- 루씬은 용어 사전을 위해 SS 테이블 같은 구조를 사용한다.

## 모든것을 메모리에 보관
- 여러 장비 간 분산해서 보관할수도 있다. -> 이러한 이유로 인해 인 메모리 데이터베이스가 개발
- Memcached 같은 키 밸류 저장소는 캐시 용도로만 사용
- 일부 데이터베이스는 지속성도 보장 한다.
- 디스크에 변경 사항의 로그를 기록하거나 디스크에 주기적인 스냅숏을 기록
- 인메모리 DB가 재시작 될 경우 디스크나 네트워크를 통해 복제본에서 상태를 다시 적재해야한다.


- 볼트 DB , 멤SQL, 오라클 타임즈텐은 관계형 모델의 인메모리 데이터베이스
- 램클라우드 =  지속성 있는 오픈소스 인메모리 키 밸류 저장소
- Redis , Couchbase는 비동기로 디스크에 기록
- 레디스는 우선순위 , Set 같은 형태의 자료구조를 제공


## 트랜잭션 처리나 분석
- 보통의 애플리케이션 트랜잭션을 Online Transaction Processing(OLTP)라고 한다.
- 데이터 분석 같은 경우는 Online Analytic Processing(OLAP)라고 한다.



