---
tags:
  - 데이터베이스
최근 수정한 날짜: "{{date}}"
책 이름: Real Mysql
챕터: 10장
읽기 시작한 날짜: 2023-09-27
다 읽은 날짜: 2023-09-28
---

## 10.1 통계 정보
- 8.0부터 인덱스 되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입

### 10.1.1 테이블 및 인덱스 통계 정보
- 통계 정보 기반으로 쿼리를 옵티마이저가 쿼리를 실행

#### 10.1.1.1 MySQL 서버의 통계 정보
- InnoDB부터는 통계정보를 테이블에 저장한다.

 - `innodb_index_stats.stat_name` =  `n_diff_pfx%` 인덱스가 가진 유니크한 값의 개수
 - `innodb_index_stats.stat_name`=`n_leaf_pages` : 인덱스의 리프 노드 페이지 개수
 - `innodb_index_stats.stat_name` = `size` : 인덱스 트리의 전체 페이지 개수
 - `innodb_table_stats.n_rows` : 테이블의 전체 레코드 건수
 - `innodb_table_stats.clustered_index_size` : 프라이머리 키의 크기(innodb 페이지 개수)
 - `innodb_table_stat.sum_of_other_index_sizes` : 프라이머리 키를 제외한 인덱스의 크기

### 10.1.2 히스토그램

- 8.0부터는 히스토그램을 활용해서 실행 계획을 수립한다.

#### 10.1.2.1 히스토그램 정보 수집 및 삭제
- 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령어를 통해서 수집 및 관리 된다.
- 히스토그램에는 2종류가 있다.
	> Singleton 히스토그램 : 컬럼 값 개별로 건수를 관리하는 히스토그램

>	Equi-height 히스토그램 : 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

- 히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다.
- 싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도의 비율의 2개 값을 가진다.
- 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 가진다.
- 싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 경우 사용된다.
- 높이 균형 히스토그램은 컬럼값의 범위에 대해 레코드 건수 비율이 누적으로 표시된다,

#### 10.1.2.2 히스토그램의 용도

- 히스토그램은 각 범위별로 레콛의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.
- 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별 할 수 있다.
- 각 컬럼에 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다..

#### 10.1.2.3 히스토그램과 인덱스
- Mysql 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.
> 인덱스 다이브(Index dive) : 조건절에 일치하는 레코드 건수를 예측하기 위해서 실제 인덱스의 B Tree를 샘플링한다.

- 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

### 10.1.3 코스트 모델

> 코스트 모델(cost Model) : 전체 쿼리의 비용을 계산하는데 필요한 단위 작업의 비용

- 8.0부터 실행 계획 수립에 사용되기 시작 함
- server cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리
- 공통으로 가지고 있는 컬럼
	- `cost_name` : 코스트 모들의 각 단위 작업
	- `default_value` : 각 단위의 작업의 비용ㅇ
	- `cost_value` : DBMS 관리자가 설정한 값
	- `last_updated` : 단위 작업의 비용이 변경 된 시점
	- `comment` : 비용에 대한 추가 설명
- enging_cost는 두개를 추가 적으로 더 가지고 있다.
	- `engine_name` : 비용이 적용된 스토리지 엔진
	- `device_type` : 디스크 타입

- 코스트 모델에서 중요한 것은 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.

## 10.2 실행 계획 확인
- `DESC` , `EXPLAIN` 명령어로 확인 할 수 있다.


### 10.2.1 실행 계획 출력 포맷
- 8.0부터는 format 옵션을 사용해 표시 방법을 JSON, TREE, 단순 테이블 형태로 선택할 수 있다.
- 트리 형태:
```sql
-> Nested loop inner join  (cost=3.06 rows=10) (actual time=0.018..0.018 rows=0 loops=1)
    -> Index lookup on e using ix_firstname (first_name='ABC')  (cost=1.10 rows=1) (actual time=0.017..0.017 rows=0 loops=1)
    -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=1.96 rows=10) (never executed)

```


### 10.2.2 쿼리의 실행 시간 확인
- `EXPLAIN ANALYZE` 명령어로 Tree 형태로 출력이 가능학 단계별 소요 시간 정보를 확인 할 수 있다.

```sql
-> Group aggregate: avg(s.salary)  (cost=495.47 rows=123) (actual time=1.168..74.057 rows=48 loops=1)
    -> Nested loop inner join  (cost=483.13 rows=123) (actual time=0.559..73.882 rows=48 loops=1)
        -> Covering index lookup on e using ix_firstname (first_name='Matt')  (cost=26.04 rows=233) (actual time=0.054..0.254 rows=233 loops=1)
        -> Filter: ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=1.01 rows=1) (actual time=0.309..0.316 rows=0 loops=233)
            -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=1.01 rows=10) (actual time=0.304..0.313 rows=10 loops=233)
```
- 들여쓰기는 호출 순서를 의미하며 실제 실행 순서는 다음 기준으로 읽으면 된다.
	- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
	- 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행
- `EXPLAIN ANALYZE` 명령의 결과에는 단계별로 소요된 시간과 처리한 레코드 건수 , 반복 횟수가 표시 된다.
- `actual_time` : 레코드를 검색하는데 걸린 시간. 값이 두개가 있는데 첫번째는 레코드를 가져오는데걸린 평균 시간. 두번째는 마지막 레코드를 가져오는 데 걸린 평균 시간
- `EXPLAIN ANALYZE` 명령어는 실제 쿼리를 실행하고 사용된 계획과 소요 시간을 보여준다.

## 10.3 실행 계획 분석
- 표의 각 레코드는 쿼리에서 사용된 테이블의 수만큼 출력된다.


### 10.3.1 id 컬럼

- `SELECT` 키워드 단위로 구분한 것을 `단위(SELECT) 쿼리` 라고 한다.
- id 컬럼은 단위 쿼리 별로 부여되는 식별자 값
- `SELECT` 문장이 하나인데 여러 개의 테이블이 조인 되는 경우에는 id 값이 증가하지 않고 같은 id가 부여된다.
- id 컬럼이 테이블의 접근 순서를 의미하지는 않는다.
- EXPLAIN ANALYZE 명령어로 순서를 더 정확히 알 수 있다.

### 10.3.2 select_type 컬럼

- 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시

#### 10.3.2.1 SIMPLE
- 단순 SELECT 쿼리인 경우 select_type은 SIMPLE로 표시 된다.
- 실행 계획에서 SIMPLE은 하나만 존재한다.
#### 10.3.2.2 PRIMARY
- `UNION` 이나 서브 쿼리를 가지는 SELECT 쿼리 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 `select_type`이 `PRIMARY` 로 표시 된다.
- `PRIMARY`는 단 하나만 존재 한다.

#### 10.3.2.3 UNION
- `UNION` 으로 결합하는 쿼리 가운데 첫번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 `select_type`은 `UNION`으로 표시 된다.
- 첫번째 단위 SELECt는 `UNION`이 아니라 쿼리를 모아서 저장하는 임시 테이블(`DERIVED`)이 표시된다.

### 10.3.2.4 