# 8 인덱스

## 8.1 디스크 읽기 방식

- 디스크의 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차 IO에서는 SSD가 하드디스크랑 성능이 비슷하거나 조금 빠르다
- 하지만 랜덤 IO가 훨씬빠르다
- 랜덤 IO 가 훨씬 많은 데이터베이스에서는 SSD가 더 좋다
- 쿼리를 튜닝해서 랜덤 IO를 순차 IO로 바꿔서 실행할방법은 그다지 많지 않다.
- 인덱스 레인지 스캔은 주로 랜덤 IO를 사용
- 풀 테이블 스캔은 순차 IO를 사용한다.
- 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀테이블 스캔을 사용을 유도할때도 있다.



## 8.2 인덱스란

- sortedList 형태의 자료구조로 인덱스를 저장한다.
- Insert나 UPDATE DELETE의 속도가 느리다
- 대표적으로 Hash 인덱스랑 B tree 인덱스로 구분
- 중복 허용 여부로 분류하면 유니크 인덱스랑 유니크 하지 않은 인덱스로 구분 할 수 있다.
- 범위를 검색할때는 해시 인덱스 사용 불가능
- InnoDB 테이블에서는 레코드는 클러스터되어 디스크에 저장된다. 이때 PK 기준으로 정렬해서 저장



## 8.3 B 트리

- MyISAM에서 레코드 주소는 테이블에 Insert 된순번 , 데이터 파일 내의 위치 Offset이다.



- InnoDB에서는 PK가 ROWID의 역할을 한다.
- MyISAM은 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 PK를 주소처럼 사용한다.
- InnoDB에서는 프라이머리 키를 저장하고 있는 B Tree를 다시 한번 검색해야 한다.



### 8.3.2 B Tree 인덱스 키 추가 및 삭제

- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.



#### 8.3.2.1 인덱스 키 추가

- B Tree에 저장 될 때는 저장될 키 값을 이용햇 적절한 위치를 찾아야 한다.
- 결정되면 레코드의 키 값과 레코드의 주소 정보를 리프 노드에 저장,
- 리프노드가 꽉 차면 분리해야 한다.
- B Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
- MyISAM에서는 바로 B Tree 인덱스에 변경한다.
- InnoDB에서는 체인지 버퍼에서 인덱스 키 추가 작업을 지연시키거나 나중에 처리할수있다.



#### 8.3.2.2 인덱스 키 삭제

- 리프 노드를 찾아 삭제 마크만 하면 작업이 완료된다.
- 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나재활용할수 있다.



#### 8.3.2.3 인덱스 키 변경

- B tree의 키 값이 변경되는 경우 삭제 -> 추가 작업을 진행
- InnoDB에서는 체인지 버퍼를 이용해 지연처리 할 수 있다.



- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.
- update나 delete 문장이 실행될 때 테이블에 적절히 사용 할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.
- 인덱스 설계가 그만큼 중요하다.



### 8.3.3 B tree 인덱스 사용에 영향을 미치는 요소

- 레코드 건수, 유니크한 인덱스 키 값이 개수, 칼럼의 크기



#### 8.3.3.1 인덱스 키 값의 크기

- InnoDb 스토리지 엔진은 디스크에 데이터를 저장하는 가장 단위를 페이지 또는 블록이라 한다.
- 디스크의 모든 읽기 쓰기 작업의 최소 작업 단위
- 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
- InnoDb에서는 페이지 크기가 기본이 16KB , 4~64KB까지 설정 가능
- 인덱스의 키가 16바이트이고 자식 노드 주소가 12바이트 일때 16KB에서는 585개 저장가능
- 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어난다.



#### 8.3.3.2 B 트리 깊이

- B Tree 깊이가 3일 경우 , 키 값이 16바이트 인경우 최대 2억개까지 저장 가능
- 32비트 일경우 5천만개 까지 가능
- 인덱스 키 값의 크기는 가능하면 작게 만드는것이 좋다.
- 아무리 대용량 데이터베이스라도 뎁스가 5단계 이상까지 깊어지는 경우는 흔치 않다.



#### 8.3.3.3 선택도

- 선택도(Selectivity) 기수성(Cardinality)는 같은 의미로 사용되며, 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 전체 인덱스 키값이 100개이고 유니크 한 수가 10개라면 기수성은 10이다.

- 인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고 선택도 또한 떨어진다.
- 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 인덱스가 유니크할수록 효율성이 좋아진다.

#### 8.3.3.4 읽어야하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.
- 테이블에 100만건이 있고 50만건을 읽어야 할 때 필요한 것만 읽을지, 모두 읽고 버리는게 효율적인지 판단해야 한다.
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드를 읽는 것보다 4~5정도 비용이 든다고 예측
- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블의 20~25%를 넘어서면 이용하지 않는것이더 좋다.



### 8.3.4 B Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- 필요한 레코드의 시작 지점을 찾는다.
- 그때부터는 리프노드의 레코드만 순서대로 읽으면 된다.
- 리프노드의 끝까지 읽으면 리프노드간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다.

- 인덱스의 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
- 레코드 한건 한건 단위로 랜덤 IO가 발생한다.



#### 8.3.4.2 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 인덱스 레인지 스캔보다 느리지만 풀테이블 스캔 보다는 효율적이다.



#### 8.3.4.3 루스 인덱스 스캔

- 인덱스 레인지 스캔과 인덱스 풀 스캔은 , 타이트 인덱스 스캔으로 분류
- 루스 인덱스 스캔은 느슨하게 인덱스를 읽는 방법
- 루스 인덱스 스캔은 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 GROUP BY나 집합 함수 가운데 MAX , MIN 함수에 대해 최적화를 하는 경우 사용된다.



#### 8.3.4.4 인덱스 스킵 스캔

- 인덱스는 컬럼의 순서가 매우 중요하다.
- 8.0부터는 옵티마이저가 컬럼을 건너뛰어서 스캔하는 최적화 기법이 도입되었다.
- 컬럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 조건을 추가해서 다시 실행하는 형태로 처리한다.
- 내부적으로 2개의 쿼리를 실행 함

```mysql
SELECT gender , birth_date from employees where gender='M' and birth_date >='1965-02-01';
SELECT gender , birth_date from employees where gender='F' and birth_date >='1965-02-01';
```

- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함(커버링 인덱스)

### 8.3.5 멀티 컬럼 인덱스

- 인덱스를 두개를 결합해서 사용한 형태
- 인덱스의 두번째 컬럼의 값은 첫번째 컬럼의 값에 의존해서 정렬되어있다.

### 8.3.5 B 트리 인덱스의 정렬 및 스캔 방향

- 인덱스를 오름차순 혹은 내림차순으로 정렬해서 저장 가능
- 읽을때도 어느 방향으로 읽을지 옵티마이저 실시간으로 만들어내는 실행 계획에 따라 다르다.



### 8.3.6 B 트리 인덱스의 정렬 및 스캔 방향

- 인덱스 포워드 스캔과 백워드 스캔에는 성능 차이가 있다.
  - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조



### 8.3.7 B Tree 인덱스의 가용성과 효율성



#### 8.3.7.1 비교 조건의 종류와 효율성

- 다중 칼럼 인덱스에서 순서와 조건이 동등 비교인지 아니면 크다 또는 작다인지에 따라 활용 형태가 다르다.



#### 8.3.7.3 가용성과 효율성 판단

- 다음과 같을 경우 인덱스 사용 불가능

  - NOT - EQUAL로 비교된 경우

  - LIKE %?? 형태로 문자열 패턴이 비교된 경우
  - 스토어드 함수나 다른 연산자로 인덱스 ,컬럼이 변형된 후 비교된 경우
  - 데이터 타입이 서로 다른 비교
  - 문자열 데이터 타입의 콜레이션이 다른 경우



## 8.5 전문 검색 인덱스

- MySQL의 B 트리 인덱스는 실제 컬럼의 값이 1MB이더라도 전체 값을 인덱스 키로 사용하는 것이 아니라, 1000바이트(MyISAM) 또는 3072 바이트 까지만 잘라서 사용한다.
- 전체 일치또는 좌측 일부 일치 같은 검색만 가능하다.





## 8.8 클러스터링 인덱스

- MySQL에서 클러스터링은 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태
- 클러스터링 인덱스는 PK에만 적용되는 내용
- PK가 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.
- 인덱스 알고리즘보다는 테이블 레코드의 저장 방식
- InnoDB 스토리지 엔진이 적절한 클러스터링 키 후보를 찾지 못하는 경우 InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 컬럼을 생성한다.



#### 8.8.2 세컨더리 인덱스에 미치는 영향

- MyISAM 테이블이나 메모리 테이블에서는 세컨더리 인덱스랑 PK랑 차이가 없다.
- InnoDB에서 세컨더리 인덱스가 레코드의 저장된 주소를 가지고 있다면
  - 키 값이 변경될때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다.
  - 세컨더리 인덱스는 해당 레코드가 아니라 PK 값을 저장하도록 구현돼있다.
  - 따라서 세컨더리 인덱스로 PK를 찾은 다음 PK로 레코드를 찾는 방식으로 동작한다.

#### 8.8.3 클러스터링 인덱스의 장점과 단점



| 장점 | - PK로 검색할 때 처리성능이 매우 빠름<br />- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리 될 수 있는 경우가 많음 |
| ---- | :----------------------------------------------------------- |
| 단점 | - 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키의 크기가 클 경우 인덱스의 크기가 커짐<br />- 세컨더리 인덱스를 통해 검색할때 PK로 다시봐야해서 느림<br />- Insert 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 느림<br />- PK를 변경할때 레코드를 DELETE하고 Insert 하는 작업이 필요하기 때문에 처리 성능이 느림 |

​	 -



- 클러스터링 테이블의 크기가 커질수록 자연스럽게 세컨더리 인덱스의 크기도 커진다.



#### 8.8.4.2 PK는 AUTO INCREMENT보다는 업무적인 컬럼으로 생성(가능한 경우)

#### 8.8.4.3 PK는 반드시 명시할것

- AI로도 만들어서 PK를 사용해라
- 없으면 InnoDB가 내부적으로 일련번호 컬럼을 추가한다.
- 자동으로 추가된 컬럼은 사용자가 사용할수 없다.



#### 8.8.4.4 AI를 인조 식별자로 사용할 경우

- 여러개의 컬럼이 복합으로 PK가 만들어지는 경우 , 프라이머리 키의 크기가 길어질 때가 있다.
- 크기가 길어도 인덱스가 필요하지 않다면 PK를 사용하는것이 좋다.
- 인덱스도 필요하고 PK도 길다면 AI를 사용
- 로그테이블과 같이 조회보다는 Insert 위즈이 테이블들은 AI를 이용한 인조 식별자를 PK로 설정하는 것이 좋다.



## 8.9 유니크 인덱스

- 유니크는 인덱스라기 보다는 제약조건에 가까움
- Mysql에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
- NULL은 특정 값이 아니라 2개 이상 저장이 가능

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

- 세컨더리 인덱스와 유니크 인덱스는 사실상 구조의 아무런 차이점이 없다.
- 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린거지 인덱스 자체의 특성때문에 느린것이 아니다.
- 유니크 하지않은 세컨더리 인덱스에서 한번 더 해야 하는 작업은 CPU에서 컬럼을 비교하는 작업이라 성능상 영향이 거의 없다.
- 하나의 값을 검색하는 경우 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다.
  - 유니크 인덱스는 찾으면 바로 종료하지만 일반 세컨더리 인덱스는 계속해서 찾아야 하기 때문에 실행 계획이 다르다.

#### 8.9.1.2 인덱스 쓰기

- 새로운 레코드가 INSERT, Update 되는 경우 인덱스 쓰기 작업이 필요
- 유니크 인덱스의 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다.
- 유니크 하지 않은 세컨더리 인덱스보다 쓰기 작업보다 느리다.
- 유니크 인덱스에서 중복된 값을 체크 할때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 발생한다.
- 중복 체크를 해야하기 때문에 느리다
- 

