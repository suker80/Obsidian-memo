### 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.



- 첫번째 단계에서 문법오류를 검출한다.
- 파스 트리를 이용해서 다음 항목을 처리한다.
  - 불필요한 조건 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 읽을지 결정
  - 조건과 인덱스 통계정보를 이용해 사용할 인덱스를 결정
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두번째 단계는 최적화 및 실행 계획 수립단계이고 옵티마이저에서 처리한다.
- 세번째 단계는 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청



## 9.2 기본 데이터 처리

### 9.2.1 풀테이블 스캔과 풀 인덱스 스캔

- 옵티마이저는 다음 조건일 경우 풀테이블 스캔을 사용한다.
  - 테이블의 레코드 건수가 너무 적어서 풀테이블 스캔을  하는경우가 더 빠를때
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 read ahead 작업이 자동으로 시작
- 리드 어헤드는 어떤 영역의 데이터가 필요할것을 예측해서 미리 읽어서 버퍼 풀에 가져다 두는 것
- 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용



### 9.2.3 ORDER BY 처리

- 정렬을 처리하는 방법은 Filesort랑 인덱스를 이용하는 방법이 있다.

- 인덱스를 사용하지 못하는 경우
  - 정렬 기준이 너무 많아서 요건별로 인덱스를 생성이 불가능
  - GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬
  - UNION 결과와 같이 임시 테이블 결과를 정렬
  - 랜덤하게 결과 레코드를 가져오는 경우

- Extra 컬럼에서 Using filesort 메시지가 표현되면 filesort 정렬을 했다.

#### 9.2.3.1 소트 버퍼

- 정렬을 하기 위해 별도의 메모리 공간을 할당받는데 이 메모리 공간을 소트 버퍼라고 한다.
- `sort_buffer_size` 시스템 변수로 설정 가능
- 정렬해야 할 레코드가 아주 소량이어서 소트 버퍼만으로 정렬 할 수 있다면 빠르게 처리
- 소트 버퍼 보다 크다면 버퍼에서 정렬을 수행하고 결과를 임시로 디스크에기록
- 레코드를 가져와서 다시 정렬한다음 반복적으로 디스크에 임시 저장
- 그리고 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행
- 이러한 과정을 멀티머지라고 표현한다.
- 개인용 PC에서 소트버퍼 크기가 256 KB ~ 8MB 사이에서 최적의 성능을 보임
- 소트 버퍼 크기를 10MB이상 설정하면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 메모리 부족 현상을 겪을 수도 있다.

#### 9.2.3.2 정렬 알고리즘

- 싱글 패스와 투패스 정렬 모드가 있다.
- <sort_key, rowid> : 정렬 키와 레코드의 row id만 가져와서 정렬하는 방식
- <sort_key, additional_fields> 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식 , 컬럼들은 가변 사이즈로 메모리 저장
- 첫번째가 투패스 , 두번째와 세번째를 싱글 패스로 명명

##### 9.2.3.2.1 싱글 패스 정렬 방식

- 소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식





![image-20230822123242282](https://p.ipic.vip/s8hv26.png)

##### 9.2.3.2.2 투패스 정렬 방식

- 정렬 대상 컬럼과 PK만 소트 버퍼에 담아서 정렬을 수행, 정렬된 순서대로 PK로 테이블을 읽어서 SELECT 할 컬럼을 가져오는 정렬 방식
- 8.0에서도 여전히 특정 조건에서는 투패스 정렬 방식을 사용
- 투패스 정렬 방식은 테이블을 두번 읽어야하지만 싱글패스는 한번 읽는다.
- 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 사용
- 싱글 패스 방식을 사용못하는 예외가 존재
  - 레코드의 크기가 max-length_for_sort_data 시스템 변수보다 클때
  - BLOB, TEXT 타입의 컬럼이 SELECT 대상에 포함될때

> 싱글 패스는 정렬 대상 레코드의 크기나 건수가 작은 경우 성능이 좋다

> 투패스 방식은 레코드의 크기나 건수가 클때 효율적



#### 9.2.3.3 정렬 처리 방법

order by를 사용하면 3가지 처리 방법중 하나로 정렬이 처리 된다.

밑으로 갈수록 성능이 떨어짐



| 정렬 처리 방법                         | Extra 컬럼 내용                 |
| -------------------------------------- | ------------------------------- |
| 인덱스를 사용한 정렬                   | 별도 표기 없음                  |
| 조인에서 드라이빙 테이블만 정렬        | Using filesort                  |
| 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary, Using filesort |

- 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적



##### 9.2.3.3.1 인덱스를 이용한 정렬

- order by에 명시된 컬럼이 드라이빙 테이블에 속하고 order by의 순서대로 생성된 인덱스가 있어야 한다.
- where 절에 첫번째로 읽는 테이블의 컬럼에 대한조건이 있다면 조건과 order by는 같은 인덱스를 사용 할 수 있어야 한다.
- B tree 계열 인덱스가 아닐 경우 인덱스를 이용한 정렬을 할 수 없다.
- 인덱스로 저장이 된다고 일부러 order by 절을 없애야 할 필요는 없다.
- 조인이 네스티드 루프 방식으로 실행되기 때문에 조인때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

- 조인을 할 경우 레코드의 견수가 몇 배로 불어남
- order by 절의 정렬 기준 커럼이 드라이빙 테이블에 포함되어있는 경우 정렬 후 조인을 처리
- 임시 테이블을 사용하지 않는다.

##### 9.2.3.3.3 임시 테이블을 이용한 정렬

- 2개 이상의 테이블을 조인하고 정렬 한다면 임시테이블이 필요할 수도 있다.
- 임시 테이블에 항상 조인의 결과를 저장하고 결과를 다시 정렬하는 과정을 수행
- 드리븐 테이블에 있는 컬럼을 통해 정렬을 할 경우 조인된 데이터를 가지고 정렬 할 수 밖에 없다.

##### 9.2.3.3.5 정렬 처리 방법의 성능 비교

- 웹서비스용 쿼리에서는 order by와 limit이 거의 필수로 사용되는 경향이 있다.
- order by나 group by 같은 작업은 where 조건을 만족하는 레코드를 limit 건수만큼만 가져와서는 처리 할 수 없다.
- 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 , 그루핑을 한 다음 limit으로 건수를 제한할 수 있다.
- 쿼리가 처리되는 방법을 `스트리밍 처리` `버퍼링 처리` 두가지 방식이 있다.

###### 9.2.3.3.4.1 스트리밍 방식

- 서버쪽에서 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식
- 쿼리를 요청하고 곧바로 첫번째 레코드를 전달받는다.
- 스트리밍 방식으로 처리되는 쿼리는 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답시간을 가짐
- 스트리밍 방식에서는 limit 같은 조건들은 실행 시간을 상당히 줄일 수 있다.

###### 9.2.3.3.4.2 버퍼링 방식

- order by나 group by는 스트리밍 되는것을 불가능하게 함
- 조건에 일치하는 모든 레코드를 가져온 다음 정렬하거나 그루핑해서 보내야 함.
- 서버에서 작업을 처리하는 동안 클라이언트는 기다려야 하기 때문에 응답속도가 느리다.
- JDBC에서는 mysql 서버로부터 받는 레코드를 내부 버퍼에 담아둔다. 마지막 레코드가 전달될 때까지 기다렸다가 모든 결과를 전달받으면 그때서야 비로소 클라이언트의 애플리케이션에 반환한다.
- JDBC에서는 전체 처리 시간이 짧고 통신 횟수가 적어 버퍼링을 한다.
- `인덱스를 사용한 정렬 방식` 만 스트리밍 형태의 처리 방식



### 9.2.4 group by 처리

- group by 쿼리도 스트리밍 처리를 할 수 없게 한다.
- group by 사용된 조건은 인덱스를 사용해서 처리될 수 없다.
- 인덱스를 이용할때
  - 차례대로 읽는 스캔 방법
  - 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔
- 인덱스를 사용하지 못할때 임시 테이블을 사용한다.



#### 9.2.4.1 인덱스 스캔을 이용하는 group by( 타이트 인덱스 스캔)

- group by 컬럼으로 이미 인덱스가 있다면 인덱스를 차례대로 읽으면서 그루핑 작업을 수행한다.
- 그룹 함수 (aggregation function)등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.
- 인덱스를 사용해서 처리할경우에는 `using index for group by`나 `using temporary, using filesort`가 표현되지 않는다.

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 group by

- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 루스 인덱스 스캔을 사용할때는 `using index for group by`가 표시된다.
- 단일 테이블에 수행되는 group by에서만 사용이 가능하다.
- prefix index는 루스 인덱스 스캔이 사용 불가능
- 루스 인덱스 스캔에서는 유니크한 값의 수가 적을수록 성능이 향상된다.
- 루스 인덱스 스캔이 사용될수 있는지 없는지는 where 조건이나 order by 절이 인덱스를 사용할수 있는지 없는지 판단하는것보다 어렵다.
   
```mysql
SELECT col1, col2 FROM tb_test GROUP BY col1, col2; 
SELECT DISTINCT col1, col2 FROM tb_test;
SELECT col1, MIN(col2) FROM tb_test GROUP BY col1; 
SELECT col1, col2 FROM tb_test WHERE col1 < const GROUP BY co1, col2;
SELECT MAX(col3), MIN(col3), col1, col2 FROM tb_test WHERE col2 > const GROUP BY col1, col2;
SELECT col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
SELECT col1, col2 FROM tb_test WHERE col3 = const GROUP BY col1, col2;
```

- 사용 불가능한 쿼리들

```mysql
-- // MIN()과 MAX() 이외의 집합 함수가 사용됐기 때문에 루스 인덱스 스캔은 사용 불가
SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;

-- // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY co1, col2;
```

#### 9.2.4.3 임시 테이블을 사용하는 group by

- group by의 기준 컬럼이 인덱스를 사용하지 못할때는 이방식을 사용한다.
- extra 컬럼에 `using temporary`가 출력이 된다.
- mysql 8부터는 묵시적인 정렬은 실행되지 않는다.
- group by가 필요한 경우 group by 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다.

### 9.2.5 DISNTINCT 처리

- 집합 함수와 함께 사용되는 경우
- 집합 함수가 없는 경우
- distinct가 인덱스를 사용하지 못할때는 임시 테이블이 필요하다
  - 그러나 `using temporary` 메시지가 출력되지 않음

#### 9.2.5.1 SELECT DISTINCT

- 유니크한 레코드만 가져오려면 select distinct 형태로 처리
- 이경우에는 group by와 동일한 방식으로 처리한다.
- distinct는 select하는 레코드를 유니크하게 select 하는것이지 특정 컬럼만 유니크하게 조회하는 것이 아니다.
- distinct는 조회되는 모든 컬럼에 영향을 미친다.
- distinct는 함수가 아님!

#### 9.2.5.2 집합 함수와 함께 사용된 distinct
- 집합 함수가 없으면 모든 컬럼의 조합이 유니크 한것만 가져옴
- 또한 집합 함수를 따로 따로 사용한다면 임시테이블을 만들어낸다.

### 9.2.6 내부 임시 테이블 활용

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용한다.
- 내부적인(internal)이라 표현하는 이유는 create temporary table 명령어로 만든 임시 테이블과는 다르기 때문이다.
- 내부적인 임시 테이블은 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 또한 다른 세션이나 쿼리에서는 볼 수 없고 쿼리가 완료되면 자동으로 삭제된다.

#### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

- 메모리는 TempTable이라는 스토리지 엔진을 사용한다. (MySQL 8.0 이후부터)
    - 최대 사용 가능한 메모리 크기는 1GB이다. 1GB가 초과하는 경우 디스크로 기록하게 된다.
    - 이 때 두 가지 방식으로 저장할 수 있다.
        1. MMAP 파일로 기록 (디폴트, InnoDB 테이블로 전환하는 것 보다 오버헤드가 적음)
        2. InnoDB 테이블로 기록
- 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용한다. (MySQL 8.0 이후부터)

#### 9.2.6.2 임시 테이블이 필요한 쿼리

- 다음과 같은 쿼리는 MySQL 엔진에서 별도의 데이터 가공이 필요하므로 내부 임시 테이블을 생성하는 대표적인 케이스이다.
    - Order by와 group by에 명시된 칼럼이 다른 쿼리
    - Order by와 group by에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
    - distinct와 order by가 동시에 쿼리에 존재하는 경우 또는 distinct가 인덱스로 처리되지 못하는 쿼리
    - union이나 union distinct가 사용된 쿼리(select_type이 union result인 경우)
    - 쿼리의 실행 계획에서 select_type이 derived인 쿼리
- 임시 테이블을 사용하는 지 여부는 실행 계획의 Extra 칼럼에 "Using temporary" 메시지가 표시되는지 확인하면 알 수 있다.

#### 9.2.6.3 임시 테이블이 디스크에생성되는 경우

- 내부 임시 테이블은 기본적으로 메모리에 만들어진다.
- 하지만 다음의 조건을 만족하면 디스크 기반의 임시 테이블을 사용한다.
    - Union이나 union all에서 select되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    - group by나 distinct 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
    - 메모리 임시 테이블의 크기가 temp_table_max_ram 시스템 변수 값보다 큰 경우

#### 9.2.6.4 임시 테이블 관련 상태 변수

- 일반적으로 실행 계획에서 "Using temporary"가 표시된 것으로 임시 테이블이 사용되었다는 것을 알 수 있다.
- 하지만 임시 테이블을 하나 사용했는지 여러개 사용했는지, 메모리에 생성됐는지 디스크에 생성됐는지는 다음의 상태 변수로 확인할 수 있다.
- show session status like 'Created_tmp%';
    - Created_tmp_tables : 내부 임시 테이블의 개수를 누적하는 상태 값
    - Created_tmp_disk_tables : 디스크에 내부 임시 테이블이 만들어진 개수를 누적하는 상태 값


# 9.3 고급 최적화
- 옵티마이저 옵션은 크게 조인 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분할 수 있다.



## 9.3.1 옵티마이저 스위치 옵션

- 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어한다.
- 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이다.



### 9.3.1.1 MRR과 배치 키 액세스
- MRR은 Multi Range Read를 줄여서 부르는 이름
- Mysql에서 지원하던 조인방식은 Nested Loop Join 방식
- Mysql 내부 구조상 조인 처리는 Mysql  엔진이 처리하고 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다.


#### 9.3.1.2 Block nested loop join

- 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있을 경우 사용되는 조인 방식
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 큰 차이는 조인 버퍼가 사용되는지 여부와, 어떤 순서로 조인되느냐 차ㅣ
- Block이 사용되면 별도의 버퍼가 사용됐음을 의미.
- `Using Join Buffer` 문구가 표시되면 조인 버퍼를 사용한다.
- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리
- 인덱스가 없으면 풀 테이블 스캔을 해야함
- 옵티마이저는 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.
- 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리
- 메모리의 캐시를 조인 버퍼라 한다.
- 8.20 부터는 블록 네스티드 루프 조인은 더이상 사용되지 않음.


#### 9.3.1.3 인덱스 컨디션 푸시다운
```sql
Alter table employees add index ix_lastname_firstname (last_name, first_name);

select * from employees where last_name='Acton' and first_name like '%sal';

```

- 위의 Select 쿼리에서 index_condition_pushdown을 off 로 설정하면 last_name을 기준으로 인덱스를 타고 first_name like '%sal' 조건은 레코드에 직접 접근해서 검사를 한다.
- 그러나 index_condition_pushdown을 on으로 설정하면 index 내에서 비교를 수행하고 비교한 대상 레코드에만 접근해서 데이터를 가져올 수 있다.
- 인덱스 컨디션 푸시다운은 언제나 활성화 되어있다.

#### 9.3.1.4 인덱스 확장
- 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.
- InnoDB 스토리지 엔진에서 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리 키를 포함한다.
- 프라이머리 키가 a 이고 세컨더리 인덱스가 b 로 되어있으면 실제로 세컨더리 인덱스는 (b, a)로 작동한다.

#### 9.3.1.5 인덱스 머지(index_merge)

- 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.
- 하나의 인덱스를 사용해서 작업 범위를 충분히 줄일 수 있는 경우라면 하나의 인덱스만 활용하는 것이 효율적이다. 하지만 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상 될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
- 인덱스 머지는 다음의 3개의 세부 실행 계획으로 나누어 볼 수 있다.
    - index_merge_intersection
    - index_merge_union
    - index_merge_sort_union
#### 9.3.1.6 인덱스 머지 - 교집합(index_merge_intersection)

- 이 실행 계획은 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합을 반환한다.
- 실행계획의 Extra 칼럼에 Using intersect로 표시됨을 확인할 수 있다.

```sql
select * from employees where first_name='George' and emp_no between 10000 and 20000;

```

- 위의 쿼리에서 두 조건에 대한 인덱스가 모두 존재하고 모두 상대적으로 많은 레코드를 가져와서 처리해야 한다면 인덱스를 각각 검색해서 교집합 하는 방식이 더 효율적일 수 있다. (물론 아닐 수도 있다.)

#### 9.3.1.7 인덱스 머지 - 합집합(index_merge_union)
- or 연산으로 연결된 경우 사용 됌
- 이 실행 계획은 여러 개의 인덱스를 각각 검색해서 그 결과의 합집합을 반환한다.
- 실행계획의 Extra 칼럼에 Using union로 표시됨을 확인할 수 있다.

```sql
select * from employees where first_name='Matt' or hire_date='2022-07-13';

```

- 이 경우 인덱스 머지 방식을 사용할 때 중복을 제거해주어야 한다.
    - 각각의 인덱스로 조회 시에 emp_no(primary key)를 기준으로 정렬이 되어있으므로 인덱스 머지를 수행할 때 각 집합에서 하나씩 가져와 비교하며 죽복된 레코드를 걸러낼 수 있다.(우선순위 큐 알고리즘)
- or 연산자로 연결된 경우 둘중의 하나라도 인덱스를 사용하지 못하면 풀테이블 스캔으로 밖에 처리하지 못한다.
#### 9.3.1.8 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)

- 위의 Union 알고리즘에서 정렬된 결과로 중복제거를 하는데 정렬이 이미 되어있으므로 필요하지 않았다.
- 하지만 도중에 정렬이 필요한 경우에는 Sort union 알고리즘을 사용한다.
#### 9.3.1.9 세미 조인
- 실제로 테이블 조인을 수행하지 않고 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지 체크하는 형태의 쿼리
```sql
select * from employees e where e.emp_no in ( select de.emp_no from dept_emp where de.from_date= '1995-01-01' );
```

- 세미 조인 형태의 쿼리와 안티 세미조인 형태의 쿼리는 최적화 방법이 조금 차이가 있다.
- =(subquery) , in(subquery) 형태의 세미 조인 쿼리에 대해 다음과 같이 3가지 방법이 있다.
	- 세미 조인 최적화
	- IN TO EXISTS 최적화
	- MATERIALIZATION 최적화
- <>(subquery) , Not In(subquery) 2가지 방법이 존재
	- IN TO EXISTS 최적화
	- MATERIALIZATION 최적화
- 세미 조인 최적화에 대해서는 다음과 같은 전략이 있다.
- - Table Pull-out
    - Duplicate Weed-out
    - First Match
    - Loose Scan
    - Materialization

#### 9.3.1.10 테이블 풀 아웃(Table pull out)
- 세미 조인의 서브 쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
- Table pull out 최적화가 사용됐는지는 실행 계획에서 해당 테이블들의 id 컬럼 값이 같은지 다른지 비교하는 방법이 제일 간단하다.
- Table Pull Out 최적화는 세미 조인 서브쿼리에서만 사용가능
- UNIQUE 인덱스나 PK 룩업으로 결과가 1건인 경우에만 사용
- 최대한 Table Pull Out을 최대한 적용
- 최대한 서브쿼리를 조인으로 풀어서 사용해라

#### 9.3.1.11 퍼스트 매치
- In 형태의 세미조인을 Exist(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다.
- Extra 컬럼에 first match가 출력된다.