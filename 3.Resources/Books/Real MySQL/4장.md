

#### 4.1.1.1 MySQL 엔진

- 접속 및 쿼리 요청을 하는 커넥션 핸들러와 SQL 파서 및 전처리기 , 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.

#### 4.1.1.2 스토리지 엔진

- 실제 데이터를 저장하거나 불러오는것은 스토리지 엔진이 전담한다.
- 스토리지 엔진은 여러개를 동시에 사용 할수있다.



#### 4.1.1.3 핸들러 API

- 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러요청이라 한다.
- InnoDB 스토리지 엔진이 핸들러 API를 통해 Mysql 엔진과 데이터를 주고받는다.



### 4.1.2 MySQL 스레딩 구조

- MYSQL 서버는 스레드 기반으로 작동
- `thread/sql/one_coonection` 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드다.





#### 4.1.2.1 포그라운드 스레드

- 포그라운드 스레드는 MySQL 서버에 접속된 클라이언트의 수만큼 존재
- 각 클라이언트가 사용자가 요청하는 쿼리 문장을 처리
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아간다.
- 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재한다.
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가  처리, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.



#### 4.1.2.2 백그라운드 스레드

- 인서트 버퍼를 병합하는 스렏
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드
- 읽기 스레드는 많이  설정할 필요가 없다.
  - 읽기 작업은 주로 클라이언트 스레드에서 처리
- 데이터의 읽기 작업은 지연될 수 없다.

### 4.1.3 메모리 할당 및 사용 구조



![img](image.png)

- 글로벌 메모리는 MySQL 서버가 실행되면서 초기화

#### 

#### 4.1.3.1 글로벌 메모리 영역

- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
- 필요에 따라 2개 이상의 메모리 공간을 할당



#### 4.1.3.2 로컬 메모리 영역

- 세션 메모리 영역이라고도 표현
- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
- 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.

### 



#### 4.1.6 쿼리 실행 구조

![img](image-20230807163522100.png)



#### 4.1.6.1 쿼리 파서

- 쿼리 문장을 토큰( MySQL이 인식 할 수있는 최소 단위의 어휘나 기호)로 분리해서 트리 형태의 구조로 만들어낸다.
- 쿼리 문장의 문법 오류는 이 과정에서 발견된다.



#### 4.1.6.2 전처리기

- 파서 트리를 기반으로 쿼리 문자엥 구조적인 문제점이 있는지 확인한다.
- 각 토큰을 테이블 이름이나, 컬럼 이름 , 내장 함수와 같은 개체를 매핑해 존재 여부와 접근 권한 등을 확인하는 과정을 수행
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

#### 4.1.6.3 옵티마이저

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할



#### 4.1.6.4 실행 엔진

- 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행



#### 4.1.6.5 핸들러

- MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할



#### 4.1.9 스레드 풀

- 엔터프라이즈 에디션은 스레드 풀을 제공하지만 커뮤니티는 제공하지 않음
- 스레드 풀은 동시에 실행 중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능
- 불필요한 Context Switching을 줄여서 오버헤드를 낮출 수 있다.



#### 4.1.10 트랜잭션 지원 메타데이터

- 테이블의 구조정보와 스토어드 프로그램 등의 정보를 딕셔너리 또는 메타데이터라고 표현
- 기존에는 파일 기반의 메타데이터로 저장
- 8.0부터는 InnoDB의 테이블에 저장하도록 개선





## 4.2 InnoDB 스토리지 엔진 아키텍처

![img](image-20230807171609327.png)



- InnoDB에서 레코드락을 지원



### 4.2.1 PK에 의한 클러스터링

- PK 값의 순서대로 디스크에 저장된다.
- 세컨더리 인덱스는 레코드의 주소 대신 PK 값을 논리적인 주소로 사용한다.
- PK는 다른 인덱스보다 비중이 높다.

### 4.2.2 외래키 지원

- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요
- 변경시에는 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요해서 락이 여러 테이블로 전파
- 데드락이 발생할때가 많다.
- `foreign_key_checks` 변수를 off로 설정하면 외래키 체크 작업을 해제 할 수 있다.



### 4.2.3 MVCC

- 잠금을 사용하지 않는 일관된 읽기를 제공
- InnoDB는 undo log를 이용해 이 기능을 구현한다.
- 하나의 레코드에 대해 여러 개의 버전이 동시에관리
- READ_COMMITTED나 그 이상의 격리 수준인 경우 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경된 상태의 데이터를 반환
- 커밋을 하면 지금의 상태를 데이터에 반영한다.
- 롤백을 하게 되면 언두 로그에 있는 데이터를 버퍼 풀로 복구하고 언두 내용의 삭제한다.

### 4.2.4 Non Locking Consistent Read

- `SERIALIZABLE` 을 제외한 격리 수준은 Insert와 연결 되지 않은 Select 작업은 잠금을 대기 하지 않고 바로 실행된다.
- InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.



### 4.2.5 자동 데드락 감지

- InnoDB 스토리지 엔진은 교착 상태를 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리
- 데드락 감지 스레드가 잠금 대기 그래프를 검사해 데드락이 발생한 트랜잭션을 종료시킨다.
- 언두 로그의 양을 기준으로 더 적은쪽 트랜잭션을 종료시킨다.
- `innodb_table_locks` 변수를 활성화 하면 테이블 락 데드락까지 감지가 가능
- 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 많은 CPU 자원을 소모
- `innodb_deadlock_detect` off 시키면 데드락 감지 스레드가 작동하지 않는다.
- `innodb_lock_wait_timeout` 변수를 활성화 하면 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 된다.



### 4.2.7 InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간.
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼도 수행
- 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤 IO를 줄일 수 있다.

#### 

#### 4.2.7.1 버퍼풀의 크기 설정

- 운영체제의 전체 메모리 공간이 8GB 이하이면 50% 정도만 버퍼 풀로 설정하고 나머지 메모리 공간은 Mysql, 운영체제 , 다른 프로그램이 사용 할 수 있는 공간으로 확보하는것이 좋다.
- 그 이상이라면 50%에서 시작해서 조금씩 올려가면서 최적점을 찾는다.
- 50GB이상이라면 15~ 30 GB를 남겨두고 나머지를 버퍼풀로 사용
- `innodb_buffer_pool_size` 변수로 설정이 가능
- 내부적으로 128MB 청크 단위로 쪼개어 관리 된다.
- 버퍼 풀은 전체를 관리하는 잠금(세마포어)로 인해 내부 잠금 경합을 많이 유발했었는데, 풀을 여러 개로 쪼개어 관리 할 수 있다.
- `innodb_buffer_pool_instances` 변수를 이용해 풀을 여러개로 관리 기본적으로 8개로 초기화



#### 4.2.7.2 버퍼 풀의 구조

- 버퍼풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
- LRU 리스트 , 플러시 리스트 , 프리 리스트 3개의 자료구조를 사용
  - Free List : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 페이지들의 목록
  - LRU 리스트는 LRU , MRU의 결합 된 형태
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것
    - 1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검색
         - 어댑티브 해시 인덱스를 이용해 페이지를 검색
         - 해당 테이블의 인덱스를 이용해서 페이지를 검색
         - 버퍼 풀에 이미 데이터 페이지가 있다면 해당 페이지의 포인터를 MRU 방향으로 승급
      2.  디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 퐁ㄴ터를 LRU 헤더 부분에 추가
      3. LRU 헤두 부분에 적재된 데이터가 실제로 읽히면 MRU 헤더 부분으로 이동
      4. 버퍼풀에서 오래 사용되지 않으면 삭제된다.
      5. 자주 접근됐다면 어댑티브 해시 인덱스에 추가

​	
