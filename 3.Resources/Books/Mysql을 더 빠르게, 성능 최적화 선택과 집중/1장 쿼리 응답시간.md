---
tags: 
최근 수정한 날짜: "{{date}}"
책 이름: Mysql을 더 빠르게, 성능 최적화 선택과 집중
챕터: 1장
읽기 시작한 날짜: 
다 읽은 날짜: 2023-11-22
---

> 쿼리 응답 시간 = 쿼리를 실행 하는데 소요되는 시간 다른 말로 `응답 시간` `쿼리시간 ` `실행 시간` `쿼리 지연 시간` 이라고도 한다.

> `소요 시간` = 쿼리를 받고 시작되고 결과 세트를 클라이언트에 전송한 시점까지의 경과 시간

> `쿼리 응답 시간`  = 여러 단계와 대기로 구성되어 있다.


## 1.1 거짓 성능에 관한 실화
- 데이터베이스에서 인덱스가 없는 쿼리 인덱스 설정해서 성능 개선 시킨 썰

## 1-2 핵심 지표(North Star)

- 쿼리 응답 시간은 실제 해결책으로 이어지는 특성이 있으므로 가장 먼저 살펴봐야 한다.
### 의미 있는 것

- `쿼리 응답 시간`은 관심을 가질 만한 메트릭

### 실행 가능 한 것

- 코드를 담당하고 있고 쿼리 응답 시간을 직접 확인 할 수 있다면 쿼리를 변경 할 수 있다.
- 응답시간을 간접적으로 최적화 할 수 있다.
- `쿼리 응답 시간` 향상에 집중해야 한다.
- 쿼리 메트릭으로 작업을 확인한 다음 느린 쿼리를 분석하고 최적화하여 응답 시간을 단축해야 한다.

## 1-3 쿼리 보고

- `쿼리 메트릭` 은 의미 있는 방식으로 수집 , 집계 보고해야 하는 원시 값이다.
- `쿼리 분석` 은 실제 수행할 작업
	- 쿼리 메트릭과 기타 정보를 분석하게 된다.
	- 쿼리를 최적화 하려면 실행 방식을 이해해야 하고, 이를 이해하려면 쿼리 보고서와 메타데이터 등 관련 정보를 사용해서 분석해야한다.
- `쿼리 보고`는 실행에 대해 중요한 통찰력을 제공하는 메트릭의 모음을 나타낸다.
	- 소스 : 쿼리 메트릭은 2개의 소스에서 비롯되며 버전 및 배포에 따라 다르다.
	- 집계 : 쿼리 메트릭 값은 정규화된 SQL 문법을 기준으로 그룹화되고 집계 된다.
	- 보고 : 쿼리 보고서는 고급 프로파일과 쿼리에 특화된 보고서로 구성됩니다.

### 소스  
- `쿼리 메트릭`은 `슬로 쿼리 로그`나 `성능 스키마`에서 비롯된다.
- `슬로 쿼리 로그`는 디스크에 있는 로그 파일이고, `성능 스키마(performance schema)`는 데이터베이스이다.
- 두개가 제공하는 메트릭이 다르다.
- `성능 스키마`는 일관 되고 9가지 메트릭을 전부 제공한다.
- 로컬과 클라우드에서 작동

#### Mysql
- 슬로 쿼리 로그는 쿼리 메트릭 9가지 중의 6개만 제공한다.( `rows_affected, select_scan , select_full_join`)은 누락
- 8.0.14 이전 버전의 슬로 쿼리 로그를 사용하기보다 성능 스키마를 사용하라

#### percona 서버
- 슬로 쿼리 로그가 더 많은 메트릭을 제공한다.
- `log_slow_rate_limit`가 구성되면 쿼리 샘플링을 지원

#### mariaDb 서버

- rows_affected 제공하지 않음.


### 집계

- 메트릭은 쿼리별로 그룹화되고 집계 된다.
- 쿼리 별로 쿼리 메트릭을 그룹화 하는 것이 응답 시간이 가장 느린 쿼리를 확인하는 최선의 방법
- 쿼리는 정규화된 SQL문을 SHA-256으로 해시로 변환해서 그룹화 한다.
- 다이제스트 텍스트(digest text)를 생성한 다음, 다이제스트 해시를 생성

- SQL문은 쿼리 샘플로 보고 될 수도 있고 아닐 수도 있다.
- 대부분의 쿼리 메트릭 도구는 보안때문에 샘플을 폐기하고, 다이제스트 텍스트와 해시만 보고한다.


| 공식(MySQL)       | 대체                            |
| ----------------- | ------------------------------- |
| SQL문             | 쿼리                            |
| 샘플              | 쿼리                            |
| 다이제스트 텍스트 | 클래스,패밀리 ,핑거프린트, 쿼리 |
| 다이제스트 해시   | 클래스 ID,                      |
|                   |                                 |


- 정규화를 할 때 다른 구문으로 같은 논리의 쿼리를 동적으로 생성하면 안된다.
- 그렇지 않다면 다른 다이제스트로 정규화되고 다른 쿼리로 보고 된다.

```mysql
SELECT name FROM captains WHERE last_name = 'Picard'
SELECT name FROM captains WHERE last_name = 'Picard' AND first_name = "Jean-Luc"
```

- 입력에 따라 Where 절을 변경하는 프로그래밍 기반의 쿼리이다. 서로 다른 다이제스트로 정규화되므로 보고 측면에서는 서로 다른 쿼리이다.

```mysql

SELECT `name` FROM star_ships WHERE class in ('galaxy')
SELECT `name` FROM star_ships WHERE class in ('galaxy','intrepid')
```

- 이 두개는 같은 그룹 쿼리이다.

#### 보고
- 각 쿼리에는 샘플 ,EXPLAIN 계획, 테이블 구조 등의 메타데이터가 있음.
- 이 모든 데이터를 저장하고 처리하고 나타내는 것은 어렵다!
- 거의 모든 쿼리 메트릭 도구는 `쿼리 프로파일`과 `쿼리 보고서` 라는 2가지 수준의 계층 구조로 데이터를 제공한다.


#### 쿼리 프로파일

- 느린 쿼리가 표시 된다.
- 느린 쿼리는  메트릭의 집계치인 정렬 메트릭과 관련이 된다.
- 정렬 메트릭이 쿼리 시간이 아니더라도 첫번째로 정렬된 쿼리를 가장 느린 쿼리라고 한다.
- 기본이 `쿼리 시간`이다.


#### 쿼리 총시간

- `쿼리 총 시간`은 실행 시간의 총 합
- 총 시간이 가장 긴 쿼리는 가장 느리고 시간이 오래 걸리는 쿼리이다.
- 쿼리 A가 응답시간이 1초이고 10번 실행되는거랑 0.1초이고 1000번 실행 되는 쿼리중 0.1 초 걸리는 쿼리가 더 느리다.
- 쿼리 B를 최적화 함으로써 시간을 가장 많이 확보 할 수 있다.

#### 실행 시간 비율 :

- 쿼리 총시간당을 실행 총 시간으로 나눈 값
- 실행 시간 비율로 정렬된 프로파일에서 첫번째가 가장 느리다.

#### 쿼리 부하
- 쿼리 E는 총 시간이 250.2초 이고 F의 총 시간이 500.1초이면 같은 총시간일때 F가 더 느리다.
- 쿼리 부하별로 정렬된 프로파일에서 부하가 가장 큰게 가장 느리다.
- 쿼리 부하가 1.0 보다 작으면 쿼리가 동시에 실행되지 않는다.


### 쿼리 보고서
- 하나의 쿼리에 대하여 알아야 할 모든 것을 보여준다.
- 기본적인 보고서에는 소스에서 비롯된 메트릭 , 최소, 최대 , 평균 , 백분위수 등 기본 통계값이 포함

## 1.4 쿼리 분석


### 쿼리 메트릭

- 9가지 메트릭은 매우 중요하다!

#### 쿼리 시간
- 쿼리 시간에는 잠금 시간이 포함되어 있다.
- 성능 스키마는 방대한 양의 이벤트를 계측하며 다음과 같은 계층 구조로 되어 있다.
- 트랜잭션
	- 명령문
		- 단계
			- 대기
- 명령문은 쿼리 메트릭이 적용되는 단계
- 단계는 명령문 문 분석, 테이블 열기 , 파일 정렬 수행과 같은 작업을 수행
- 대기는 시간이 걸리는 이벤트

#### 잠금 시간
- 잠금 시간은 적은게 이상적이지만 상대적이다.
- 잠금 시간이 쿼리 시간의 50% 이상이면 문제가 있을수도 있다.
- 성능 스키마의 잠금 시간에는 로우락(레코드락) 대기가 포함되지 않고 테이블과 메타데이터 락만 있다.
- 슬로 쿼리 로그에는 모든 락 대기가 포함된다.
- 락 대기의 유형을 따로 표시 하지는 않는다.
- 쓰기에 대한 응답 시간은 잠금 시간에 따라 다르고 동시성에 따라 달라진다.
- 읽기 에는 `비잠금 읽기`와 `잠금 읽기`가 있다.
- 잠금 읽기 `SELECT FOR UPDATE`는 확장이 어렵고 문제를 일으키는 경향이 있어서 피해야 한다.
- `비잠금 읽기`는 메타데이터락과 레코드락 테이블 락을 얻는다.
- `ALTER TABLE`은 배타 메타데이터 락을 획득하는 일반적인 작업이다.

관련 몇가지 사항에 대해 알고 있으면 좋다.

- `innodb_lock_wait_timeout`은 각각의 로우락에 적용되므로 잠금 시간은 이보다 더 클 수 있다.
- 잠금과 트랜잭션 격리 수준은 관련되어 있다.
- InnoDB는 쓰지 않는 행을 포함하여 접근 하는 모든 행을 잠근다.
- 잠금은 커밋이나 롤백할때 해제 되며 , 때로는 실행중에도 해제된다.
- record, gap , next-key등 여러 락이 존재한다.

#### 조회 된 행

- 쿼리와 인덱스의 선택도가 높을 수록 일치하지 않는 행을 조회하는데 소비되는 시간이 줄어든다.
- 인덱스를 사용하면 좀 더 조건에 맞게 행을 조회 할 수 있다.

#### 보낸 행

- 보낸 행은 클라이언트에 보낸 행의 갯수를 뜻한다.

##### 보낸 행 = 조회된 행
- 행과 조회된 행이 같고 , 행의 백분율로 계산 했을 때 상대적으로 값이 작고 , 허용 할 수 있는 쿼리 응답 시간일때 이상적이다.
- 보낸 행과 조회된 행이 같고 값이 의심스러울 정도로 높으면 쿼리가 테이블 스캔을 유발한다.

##### 보낸 행 < 조회된 행
- 인덱스의 선택도가 좋지 않다는 신뢰할 만한 신호이다.
- 개선의 여지가 있음

##### 보낸 행 > 조회된 행
- 가능하지만 드문 경우
- `count(id) from t2`는 1개 행을 보내지만 0개 행을 조회한다.

#### 영향 받은 행

- 삽입, 갱신 , 삭제로 영향받은 행의 수를 나타낸다.
- 영향받은 행의 값은 항상 정확하다.
- 대량 INSERT나 UPDATE DELETE는 여러 성능저하 문제를 야기한다.
- 배치 크기를 잘 설정해야 한다.

#### 셀렉트 스캔
- 첫번째로 접근한 테이블에서 수행한 전체 테이블 스캔 횟수
- 인덱스를 사용하지 않아서 일반적으로 성능에 좋지 않다.
- 가끔 카디널리티와 테이블의 전체 행 수, 기타 비용을 고려해 조회할 행 수를 추정하기 때문에 테이블 스캔을 할 수도 있다.

#### 셀렉트 풀 조인
- 조인된 테이블을 대상으로 전체 테이블을 스캔한 수
- 셀렉트 스캔보다 더 나쁘고 셀렉트 풀 조인을 한다면 쿼리 최적화를 해야한다.
- 조인 순서는 EXPLAIN으로 확인 해봐야 한다.
- 쿼리 실행 중에 발생하는 풀 조인의 수가 이전 테이블의 행의 곱과 같아서 셀렉트 스캔보다 더 나쁘다!

#### 디스크에 생성된 임시 테이블
- 임시테이블의 수를 나타낸다.
- 임시 테이블 관련 변수를 수정하기 보다 쿼리를 먼저 최적화 해야 한다.
- 임시 테이블을 만드는 작업을 피하려고 하기 때문에 일반적인 문제는 아니다

#### 쿼리 카운트

- 쿼리 실행 횟수를 나타낸다.
- 낮고 느린 경우 이상한 조합이므로 조사해야 한다.
### 메타데이터와 애플리케이션

- EXPLAIN 키워드 실행계획과 테이블의 구조는 쿼리 분석을 하는데 필수적인 정보들이다.
- 애플리케이션 정보도 분석에 많이 활용이 된다.
- 애플리케이션이 쿼리를 실행하는 이유를 알면 도움이 된다.
- 쿼리 메트릭, 메타데이터 , 애플리케이션 순으로 조사하는것이 좋다.


### 평균 백분위수 , 최대

- 평균은 지나치게 낙관적이다.
- 백분위수는 어디까지나 추정
- 최대는 최상의 표현

#### 평균

- 평균의 함정에 빠지면 안된다.
- 평균 아래를 무시하는 작업은 지나치게 낙관적이다.
- 많은 의미를 두지 않아도 된다.
#### 백분위수

- P95는 샘플의 95%가 이보다 작거나 같은값이다.
- P95가 100ms라면 5%는 100ms보다 크고, 95%는 100ms보다 작다.
- 무시되는 작은 비율을 특잇값으로 간주해서 무시할수 있기때문이다.
- 네트워크 장애 이러한 작업은 Mysql의 결함이 아니기때문에 특잇값으로 무시한다.
- 가장 바람직한 백분위수는 P999이다.

#### 최대

- 일부 어플리케이션 사용자는 최대 응답 시간을 경험했거나 서비스를 이탈한다.
- 해당 샘플을 사용해 문제를 재현하거나, 재현하지 못하거나하는 일을 하게 된다.
- 기본 통계는 쿼리가 안정적인지 판단하기에 충분할 정도로 분포 경향이 비슷하다.


## 1.5 쿼리 응답 시간 개선

## 직접 최적화
- 쿼리와 인덱스를 변경 하는 작업
- 직접 쿼리 최적화가 필요조건이지만 충분 조건은 아니다.
- 더이상 최적화 할 수 없을때 간접 쿼리 최적화를 해야 한다.

### 간접 쿼리 최적화

- 쿼리가 접근 하는 대상과 방법을 변경한다.
- 하나의 예시로 TRUNCATE로 데이터를 줄이는 작업은 쿼리 최적화에 도움이 된다.
- 간접 쿼리 최적화는 더 많은 노력이 필요하다.
- 직접 쿼리 최적화를 할 수 있다면 간접 쿼리 최적화는 하지 않는게 좋다.
- 그럼에도 불구하고, 성능 개선이 필요하다면 간접 쿼리 최적화를 해야한다.

## 1.6 언제 쿼리를 최적화 해야 할까?

### 성능이 고객에게 영향을 미칠때
- 최적화를 의무적으로 해야한다.

### 코드 변경 전후

- 코드 변경 전후에 쿼리 메트릭을 검토하고 변경여부를 결정한다.

### 한달에 한번

- 좋은 쿼리가 나쁜 쿼리가 되는 시점이 있다.
- 한달에 한번 쿼리 메트릭을 분석하면 이상적인 엔지니어가 될 수 있다.

## 1.7 Mysql을 더 빠르게

- 쿼리나 애플리케이션을 변경 하지 않고 빠르게 만드는 방법은 없다.


## 요점 정리

- 성능은 쿼리 시간, 즉 Mysql이 쿼리를 실행하는 데 걸리는 시간
- 쿼리 응답 시간은 의미 있고 실행 가능하므로 핵심 지표이다.
- 쿼리 메트릭은 슬로 쿼리 로그나 성능 스키마에서 비롯된다.
- 성능 스키마는 쿼리 메트릭 중 최상의 소스이다.
- 쿼리 메트릭은 다이제스트에 의해 그룹화 되고 집계 된다.
- 쿼리 프로파일은 느린 쿼리를 보여주며 느리다는 것은 정렬 메트릭과 관련된다.
- 쿼리 보고서는 하나의 쿼리를 대상으로 모든 정보를 보여주며 쿼리 분석에 사용한다.
- 쿼리 분석의 목표는 느린 응답시간을 해결 하는 것이 아니라 쿼리 실행을 이해하는 것이다.
- ㅝ리 분석에는 쿼리 메트릭 ,메타데이터, 어플리케이션 지식을 사용한다.
- 쿼리 시간, 잠금 시간 ,조회된 행, 보낸 행, 영향 받은 행, 셀렉트 스캔, 셀렉트 풀 조인 ,임시 테이블 ,쿼리 카운트 메트릭은 매우 중요하다.
- 최적화 방법에는 간접과 직접 최적화 두가지 방법이 있다.
- 최소한 3가지 상황에서 쿼리 프로파일을 검토하고 느린 쿼리를 최적화 한다.
- 
